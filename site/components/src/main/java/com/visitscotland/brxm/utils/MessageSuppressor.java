package com.visitscotland.brxm.utils;

import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.*;


@Component
public class MessageSuppressor {

    private static final Logger logger = LoggerFactory.getLogger(MessageSuppressor.class);

    private Properties properties;

    List<Message> messages = new ArrayList<>();

    @Autowired
    public void setProperties(Properties properties){
        this.properties = properties;
    }

    public boolean canLog(String message, Object... args){
        Message issue = new Message(message, args);

        int index = messages.indexOf(issue);

        if (index < 0) {
            cleanUpIfNeeded();
            issue.log();
            messages.add(issue);
        } else {
            issue = messages.get(index);
            Date doNotLogUntil = new Date(issue.getFirstOccurrence().getTime() + properties.getContentCacheRetention());
            if (new Date().after(doNotLogUntil)){
                //TODO: verify that the messages go together
                logger.info("The next content message has been logged {} time(s) in the last {}s", issue.getCount(), properties.getContentCacheRetention());
                issue.reset();
            } else {
                return false;
            }
        }
        return true;
    }

    private void cleanUpIfNeeded(){
        if (messages.size() >= properties.getContentCacheMaxElements()){

            long cutPoint = new Date().getTime() - properties.getContentCacheRetention();
            List<Message> removeElements = new ArrayList<>();
            double percentage;

            for (Message message: messages){
                if (message.getLastOccurrence().getTime() < cutPoint){
                    removeElements.add(message);
                }
            }

            percentage = 100. * removeElements.size() / properties.getContentCacheRetention();

            if (percentage < 10) {
                logger.error("Suppressor Clean up, only reduced the amount of elements by {}%. It is advised to increase " +
                                "the maximum number of elements for the cache", percentage);
            } else {
                logger.warn("Suppressor Clean up invoked because more than {} messages were recorded. The size of the cache was reduced by {}%",
                        properties.getContentCacheRetention(), (int) percentage);
            }

            messages.removeAll(removeElements);
        }
    }

    static class Message implements Comparable<Message> {
        private final String template;
        private final Object[] arguments;
        private Date firstOccurrence;
        private Date lastOccurrence;
        private int count = 0;

        private Message(String template, Object... args){
            this.template = template;
            this.arguments = args;
        }

        public String getTemplate() {
            return template;
        }

        public Object[] getArguments() {
            return arguments;
        }

        public Date getFirstOccurrence() {
            return firstOccurrence;
        }

        public Date getLastOccurrence() {
            return lastOccurrence;
        }

        public int getCount() {
            return count;
        }

        @Override
        public int compareTo(@NotNull MessageSuppressor.Message message) {
            return getLastOccurrence().compareTo(message.getLastOccurrence());
        }

        void log(){
            count++;
            lastOccurrence = new Date();
            if (firstOccurrence == null ){
                firstOccurrence = lastOccurrence;
            }
        }

        void reset(){
            count = 1;
            lastOccurrence = new Date();
            firstOccurrence = lastOccurrence;
        }

        //Autogenerated by IntelliJ
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Message message1 = (Message) o;
            if (!template.equals(message1.template)) return false;
            return Arrays.equals(arguments, message1.arguments);
        }

        //Autogenerated by IntelliJ
        @Override
        public int hashCode() {
            int result = template.hashCode();
            result = 31 * result + Arrays.hashCode(arguments);
            return result;
        }
    }
}
